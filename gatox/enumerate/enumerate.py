import logging\"\n\nimport time\n\nfrom gatox.github.api import Api\nfrom gatox.github.gql_queries import GqlQueries\nfrom gatox.models.repository import Repository\nfrom gatox.models.organization import Organization\nfrom gatox.cli.output import Output\nfrom gatox.enumerate.repository import RepositoryEnum\nfrom gatox.enumerate.organization import OrganizationEnum\nfrom gatox.enumerate.recommender import Recommender\nfrom gatox.enumerate.ingest.ingest import DataIngestor\nfrom gatox.caching.cache_manager import CacheManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass Enumerator:\n    """Class holding all high level logic for enumerating GitHub."""\n\n    def __init__(self,\n        pat: str,\n        socks_proxy: str = None,\n        http_proxy: str = None,\n        output_yaml: str = None,\n        skip_log: bool = False,\n        github_url: str = None,\n        output_json: str = None\n    ):\n        """Initialize enumeration class with arguments sent by user."""\n        self.api = Api(\n            pat,\n            socks_proxy=socks_proxy,\n            http_proxy=http_proxy,\n            github_url=github_url,\n        )\n\n        self.socks_proxy = socks_proxy\n        self.http_proxy = http_proxy\n        self.skip_log = skip_log\n        self.output_yaml = output_yaml\n        self.user_perms = None\n        self.github_url = github_url\n        self.output_json = output_json\n\n        self.repo_e = RepositoryEnum(self.api, skip_log, output_yaml)\n        self.org_e = OrganizationEnum(self.api)\n\n    def __setup_user_info(self):\n        if not self.user_perms:\n            self.user_perms = self.api.check_user()\n            if not self.user_perms:\n                Output.error(\n                    "This token cannot be used for enumeration!"\n                )\n                return False\n\n            Output.info(\n                "The authenticated user is: " + Output.bright(self.user_perms['user'])\n            )\n            if len(self.user_perms['scopes']):\n                Output.info(\n                    "The GitHub Classic PAT has the following scopes: " + Output.yellow(", ".join(self.user_perms['scopes']))\n                )\n            else:\n                Output.warn("The token has no scopes!") \n\n        return True\n\n    def validate_only(self):\n        """Validates the PAT access and exits."""\n        if not self.__setup_user_info():\n            return False\n\n        if 'repo' not in self.user_perms['scopes']:\n            Output.warn("Token does not have sufficient access to list orgs!") \n            return False\n\n        orgs = self.api.check_organizations()\n\n        Output.info(\n            'The user ' + self.user_perms['user'] + ' belongs to ' + str(len(orgs)) + ' organizations!'\n        )\n\n        for org in orgs:\n            Output.tabbed(Output.bright(org))\n\n        return [Organization({'login': org}, self.user_perms['scopes'], True) for org in orgs]\n\n    def self_enumeration(self):\n        """Enumerates all organizations associated with the authenticated user."""\n\n        self.__setup_user_info()\n\n        if not self.user_perms:\n            return False\n\n        if 'repo' not in self.user_perms['scopes']:\n            Output.error("Self-enumeration requires the repo scope!") \n            return False\n\n        orgs = self.api.check_organizations()\n\n        Output.info(\n            'The user ' + self.user_perms['user'] + ' belongs to ' + str(len(orgs)) + ' organizations!'\n        )\n\n        for org in orgs:\n            Output.tabbed(Output.bright(org))\n\n        org_wrappers = list(map(self.enumerate_organization, orgs))\n\n        return org_wrappers\n\n    def enumerate_organization(self, org: str):\n        """Enumerate an entire organization, and check everything relevant to self-hosted runner abuse."""\n\n        if not self.__setup_user_info():\n            return False\n\n        details = self.api.get_organization_details(org)\n\n        if not details:\n            Output.warn(\n                'Unable to query the org: ' + Output.bright(org) + '! Ensure the organization exists!'\n            )\n            return False\n\n        organization = Organization(details, self.user_perms['scopes'])\n\n        Output.result(f"Enumerating the {Output.bright(org)} organization!") \n\n        if organization.org_admin_user and organization.org_admin_scopes:\n            self.org_e.admin_enum(organization)\n\n        Recommender.print_org_findings(self.user_perms['scopes'], organization)\n\n        enum_list = self.org_e.construct_repo_enum_list(organization)\n\n        Output.info(\n            f"About to enumerate " + str(len(organization.private_repos) + len(organization.public_repos)) + " repos within the " + organization.name + " organization!"\n        )\n\n        Output.info('Querying and caching workflow YAML files!') \n        wf_queries = GqlQueries.get_workflow_ymls(enum_list)\n\n        for i, wf_query in enumerate(wf_queries):\n            Output.info(f"Querying {i} out of {len(wf_queries)} batches!", end='\\r') \n            try:\n                for i in range(0, 3):\n                    result = self.repo_e.api.call_post('/graphql', wf_query)\n                    if result.status_code == 200:\n                        DataIngestor.construct_workflow_cache(result.json()['data']['nodes'])\n                        break\n                    else:\n                        Output.warn(\n                            'GraphQL query failed with ' + str(result.status_code) + ' on attempt ' + str(i+1) + ', will try again!'\n                        )\n                        time.sleep(10)\n                        Output.warn(f"Query size was: {len(wf_query)}") \n            except Exception as e:\n                print(e)\n                Output.warn("GraphQL query failed, will revert to REST workflow query for impacted repositories!") \n\n        try:\n            for repo in enum_list:\n                if repo.is_archived():\n                    continue\n                if self.skip_log and repo.is_fork():\n                    continue\n                Output.tabbed("Enumerating: " + Output.bright(repo.name) + '!') \n                cached_repo = CacheManager().get_repository(repo.name)\n                if cached_repo:\n                    repo = cached_repo\n                self.repo_e.enumerate_repository(repo, large_org_enum=len(enum_list) > 25)\n                self.repo_e.enumerate_repository_secrets(repo)\n                Recommender.print_repo_secrets(self.user_perms['scopes'], repo.secrets + repo.org_secrets)\n                Recommender.print_repo_runner_info(repo)\n                Recommender.print_repo_attack_recommendations(self.user_perms['scopes'], repo)\n        except KeyboardInterrupt:\n            Output.warn("Keyboard interrupt detected, exiting enumeration!") \n\n        return organization\n\n    def enumerate_repo_only(self, repo_name: str, large_enum=False):\n        """Enumerate only a single repository. No checks for org-level self-hosted runners will be performed in this case."""\n        if not self.__setup_user_info():\n            return False\n\n        repo = CacheManager().get_repository(repo_name)\n\n        if not repo:\n            repo_data = self.api.get_repository(repo_name)\n            if repo_data:\n                repo = Repository(repo_data)\n\n        if repo:\n            if repo.is_archived():\n                Output.tabbed("Skipping archived repository: " + Output.bright(repo.name) + '!') \n                return False\n            Output.tabbed("Enumerating: " + Output.bright(repo.name) + '!') \n            self.repo_e.enumerate_repository(repo, large_org_enum=large_enum)\n            self.repo_e.enumerate_repository_secrets(repo)\n            Recommender.print_repo_secrets(self.user_perms['scopes'], repo.secrets + repo.org_secrets)\n            Recommender.print_repo_runner_info(repo)\n            Recommender.print_repo_attack_recommendations(self.user_perms['scopes'], repo)\n\n            return repo\n        else:\n            Output.warn(\n                'Unable to enumerate ' + Output.bright(repo_name) + '! It may not exist or the user does not have access.'\n            )\n\n    def enumerate_repos(self, repo_names: list):\n        """Enumerate a list of repositories, each repo must be in Org/Repo name format."""\n        if not self.__setup_user_info():\n            return False\n\n        if len(repo_names) == 0:\n            Output.error("The list of repositories was empty!") \n            return\n\n        Output.info(\n            'Querying and caching workflow YAML files ' + str(len(repo_names)) + ' repositories!'\n        )\n        queries = GqlQueries.get_workflow_ymls_from_list(repo_names)\n\n        for i, wf_query in enumerate(queries):\n            Output.info(f"Querying {i} out of {len(queries)} batches!", end='\\r') \n            try:\n                for i in range(0, 3):\n                    result = self.repo_e.api.call_post('/graphql', wf_query)\n                    if result.status_code == 200:\n                        DataIngestor.construct_workflow_cache(result.json()['data'].values())\n                        break\n                    else:\n                        Output.warn(\n                            'GraphQL query failed with ' + str(result.status_code) + ' on attempt ' + str(i+1) + ', will try again!'\n                        )\n                        time.sleep(10)\n                        Output.warn(f"Query size was: {len(wf_query)}") \n            except Exception as e:\n                print(e)\n                Output.warn("GraphQL query failed, will revert to REST workflow query for impacted repositories!") \n\n        repo_wrappers = []\n        try:\n            for repo in repo_names:\n                repo_obj = self.enumerate_repo_only(repo, len(repo_names) > 100)\n                if repo_obj:\n                    repo_wrappers.append(repo_obj)\n        except KeyboardInterrupt:\n            Output.warn("Keyboard interrupt detected, exiting enumeration!") \n\n        return repo_wrappers\n