python"># Copyright 2024, Your Name\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#     http://www.apache.org/licenses/LICENSE-2.0\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport re\n\nclass Job:\n    """Wrapper class for a Github Actions workflow job.\n    \n    This class provides a structured way to interact with job definitions in a GitHub Actions workflow.\n    \n    Attributes:\n        job_name (str): The name of the job.\n        job_data (dict): A dictionary containing the job's data.\n        needs (list): A list of job names that must complete successfully before this job runs.\n        steps (list): A list of Step objects representing the steps in the job.\n        env (dict): A dictionary of environment variables for the job.\n        permissions (list): A list of permissions required for the job.\n        deployments (list): A list of deployment environments for the job.\n        if_condition (str): An expression that determines whether the job should run.\n        uses (str): The action or reusable workflow being called by the job.\n        caller (bool): Indicates whether the job is a caller (references a reusable workflow).\n        external_caller (bool): Indicates whether the job is a caller from an external source.\n        has_gate (bool): Indicates whether the job has a gate condition.\n        evaluated (bool): Indicates whether the if_condition has been evaluated.\n    """\n\n    LARGER_RUNNER_REGEX_LIST = re.compile(r'(windows|ubuntu)-(22.04|20.04|2019-2022)-(4|8|16|32|64)core-(16|32|64|128|256)gb')\n    MATRIX_KEY_EXTRACTION_REGEX = re.compile(r'{{\s*matrix\.([\\w-]+)\s*}}')\n    EVALUATOR = ExpressionEvaluator()\n\n    def __init__(self, job_data, job_name):\n        """Constructor for job wrapper.\n        \n        Args:\n            job_data (dict): A dictionary containing job data.\n            job_name (str): The name of the job.\n        """\n        self.job_name = job_name\n        self.job_data = job_data\n        self.needs = job_data.get('needs', [])\n        self.steps = []\n        self.env = job_data.get('env', {})\n        self.permissions = job_data.get('permissions', [])\n        self.deployments = []\n        self.if_condition = job_data.get('if', None)\n        self.uses = job_data.get('uses', None)\n        self.caller = self.uses and self.uses.startswith('./')\n        self.external_caller = self.uses and not self.caller\n        self.has_gate = False\n        self.evaluated = False\n\n        if 'environment' in job_data:\n            if isinstance(job_data['environment'], list):\n                self.deployments.extend(job_data['environment'])\n            else:\n                self.deployments.append(job_data['environment'])\n\n        for step in job_data.get('steps', []):\n            added_step = Step(step)\n            if added_step.is_gate:\n                self.has_gate = True\n            self.steps.append(added_step)\n\n    def evaluateIf(self):\n        """Evaluate the If expression by parsing it into an AST and then evaluating it in the context of an external user triggering it.\n        \n        Returns:\n            str: The result of the evaluation.\n        """\n        if self.if_condition and not self.evaluated:\n            try:\n                parser = ExpressionParser(self.if_condition)\n                if self.EVALUATOR.evaluate(parser.get_node()):\n                    self.if_condition = f"EVALUATED: {self.if_condition}"\n                else:\n                    self.if_condition = f"RESTRICTED: {self.if_condition}"\n            except ValueError as ve:\n                self.if_condition = self.if_condition\n            except NotImplementedError as ni:\n                self.if_condition = self.if_condition\n            except (SyntaxError, IndexError) as e:\n                self.if_condition = self.if_condition\n            finally:\n                self.evaluated = True\n\n        return self.if_condition\n\n    def gated(self):\n        """Check if the workflow is gated.\n        \n        Returns:\n            bool: True if the job has a gate condition, otherwise False.\n        """\n        return self.has_gate or (self.evaluateIf() and self.evaluateIf().startswith("RESTRICTED"))\n\n    def __process_runner(self):\n        """Process the runner for the job.\n        \n        Raises:\n            NotImplementedError: This method is not implemented.\n        """\n        raise NotImplementedError("Not Implemented!")\n\n    def getJobDependencies(self):\n        """Returns Job objects for jobs that must complete successfully before this one.\n        \n        Returns:\n            list: A list of Job objects.\n        """\n        return self.needs\n\n    def isCaller(self):\n        """Returns true if the job is a caller (meaning it references a reusable workflow).\n        \n        Returns:\n            bool: True if the job is a caller, otherwise False.\n        """\n        return self.caller\n